.TH "Simple Interface - Double Complex" 3 "Thu Sep 15 2011" "Version 2.4.1" "PLASMA" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Simple Interface - Double Complex \- 
.SS "Functions/Subroutines"

.in +1c
.ti -1c
.RI "int \fBPLASMA_zcgels\fP (PLASMA_enum trans, int M, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t *X, int LDX, int *ITER)"
.br
.ti -1c
.RI "int \fBPLASMA_zcgesv\fP (int N, int NRHS, PLASMA_Complex64_t *A, int LDA, int *IPIV, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t *X, int LDX, int *ITER)"
.br
.ti -1c
.RI "int \fBPLASMA_zcposv\fP (PLASMA_enum uplo, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t *X, int LDX, int *ITER)"
.br
.ti -1c
.RI "int \fBPLASMA_zcungesv\fP (PLASMA_enum trans, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t *X, int LDX, int *ITER)"
.br
.ti -1c
.RI "int \fBPLASMA_zgebrd\fP (PLASMA_enum jobu, PLASMA_enum jobvt, int M, int N, PLASMA_Complex64_t *A, int LDA, double *D, double *E, PLASMA_Complex64_t *U, int LDU, PLASMA_Complex64_t *VT, int LDVT, \fBPLASMA_desc\fP *descT)"
.br
.ti -1c
.RI "int \fBPLASMA_zgelqf\fP (int M, int N, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T)"
.br
.ti -1c
.RI "int \fBPLASMA_zgelqs\fP (int M, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgels\fP (PLASMA_enum trans, int M, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgemm\fP (PLASMA_enum transA, PLASMA_enum transB, int M, int N, int K, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zgeqrf\fP (int M, int N, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T)"
.br
.ti -1c
.RI "int \fBPLASMA_zgeqrs\fP (int M, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgesv\fP (int N, int NRHS, PLASMA_Complex64_t *A, int LDA, int *IPIV, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgesv_incpiv\fP (int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgesvd\fP (PLASMA_enum jobu, PLASMA_enum jobvt, int M, int N, PLASMA_Complex64_t *A, int LDA, double *S, PLASMA_Complex64_t *U, int LDU, PLASMA_Complex64_t *VT, int LDVT, \fBPLASMA_desc\fP *descT)"
.br
.ti -1c
.RI "int \fBPLASMA_zgetrf\fP (int M, int N, PLASMA_Complex64_t *A, int LDA, int *IPIV)"
.br
.ti -1c
.RI "int \fBPLASMA_zgetrf_incpiv\fP (int M, int N, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *L, int *IPIV)"
.br
.ti -1c
.RI "int \fBPLASMA_zgetrs\fP (PLASMA_enum trans, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, int *IPIV, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zgetrs_incpiv\fP (PLASMA_enum trans, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zheev\fP (PLASMA_enum jobz, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, double *W, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "int \fBPLASMA_zheevd\fP (PLASMA_enum jobz, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, double *W, \fBPLASMA_desc\fP *T, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "int \fBPLASMA_zhegst\fP (PLASMA_enum itype, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zhegv\fP (PLASMA_enum itype, PLASMA_enum jobz, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, double *W, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "int \fBPLASMA_zhemm\fP (PLASMA_enum side, PLASMA_enum uplo, int M, int N, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zher2k\fP (PLASMA_enum uplo, PLASMA_enum trans, int N, int K, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, double beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zherk\fP (PLASMA_enum uplo, PLASMA_enum trans, int N, int K, double alpha, PLASMA_Complex64_t *A, int LDA, double beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zhetrd\fP (PLASMA_enum jobz, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, double *D, double *E, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "double \fBPLASMA_zlange\fP (PLASMA_enum norm, int M, int N, PLASMA_Complex64_t *A, int LDA, double *work)"
.br
.ti -1c
.RI "double \fBPLASMA_zlanhe\fP (PLASMA_enum norm, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, double *work)"
.br
.ti -1c
.RI "double \fBPLASMA_zlansy\fP (PLASMA_enum norm, PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA, double *work)"
.br
.ti -1c
.RI "int \fBPLASMA_zlaswp\fP (int N, PLASMA_Complex64_t *A, int LDA, int K1, int K2, int *IPIV, int INCX)"
.br
.ti -1c
.RI "int \fBPLASMA_zlauum\fP (PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA)"
.br
.ti -1c
.RI "int \fBPLASMA_zplghe\fP (double bump, int N, PLASMA_Complex64_t *A, int LDA, unsigned long long int seed)"
.br
.ti -1c
.RI "int \fBPLASMA_zplgsy\fP (PLASMA_Complex64_t bump, int N, PLASMA_Complex64_t *A, int LDA, unsigned long long int seed)"
.br
.ti -1c
.RI "int \fBPLASMA_zplrnt\fP (int M, int N, PLASMA_Complex64_t *A, int LDA, unsigned long long int seed)"
.br
.ti -1c
.RI "int \fBPLASMA_zposv\fP (PLASMA_enum uplo, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zpotrf\fP (PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA)"
.br
.ti -1c
.RI "int \fBPLASMA_zpotri\fP (PLASMA_enum uplo, int N, PLASMA_Complex64_t *A, int LDA)"
.br
.ti -1c
.RI "int \fBPLASMA_zpotrs\fP (PLASMA_enum uplo, int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zsymm\fP (PLASMA_enum side, PLASMA_enum uplo, int M, int N, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zsyr2k\fP (PLASMA_enum uplo, PLASMA_enum trans, int N, int K, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB, PLASMA_Complex64_t beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_zsyrk\fP (PLASMA_enum uplo, PLASMA_enum trans, int N, int K, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t beta, PLASMA_Complex64_t *C, int LDC)"
.br
.ti -1c
.RI "int \fBPLASMA_ztrmm\fP (PLASMA_enum side, PLASMA_enum uplo, PLASMA_enum transA, PLASMA_enum diag, int N, int NRHS, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_ztrsm\fP (PLASMA_enum side, PLASMA_enum uplo, PLASMA_enum transA, PLASMA_enum diag, int N, int NRHS, PLASMA_Complex64_t alpha, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_ztrsmpl\fP (int N, int NRHS, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_ztrtri\fP (PLASMA_enum uplo, PLASMA_enum diag, int N, PLASMA_Complex64_t *A, int LDA)"
.br
.ti -1c
.RI "int \fBPLASMA_zunglq\fP (int M, int N, int K, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "int \fBPLASMA_zungqr\fP (int M, int N, int K, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *Q, int LDQ)"
.br
.ti -1c
.RI "int \fBPLASMA_zunmlq\fP (PLASMA_enum side, PLASMA_enum trans, int M, int N, int K, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zunmqr\fP (PLASMA_enum side, PLASMA_enum trans, int M, int N, int K, PLASMA_Complex64_t *A, int LDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, int LDB)"
.br
.ti -1c
.RI "int \fBPLASMA_zLapack_to_Tile\fP (PLASMA_Complex64_t *Af77, int LDA, \fBPLASMA_desc\fP *A)"
.br
.ti -1c
.RI "int \fBPLASMA_zTile_to_Lapack\fP (\fBPLASMA_desc\fP *A, PLASMA_Complex64_t *Af77, int LDA)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This is the group of double complex functions using the simple user interface. 
.SH "Function/Subroutine Documentation"
.PP 
.SS "int PLASMA_zcgels (PLASMA_enumtrans, intM, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_t *X, intLDX, int *ITER)"PLASMA_zcgels - Solves overdetermined or underdetermined linear systems involving an M-by-N matrix A using the QR or the LQ factorization of A. It is assumed that A has full rank. The following options are provided:
.PP
# trans = PlasmaNoTrans and M >= N: find the least squares solution of an overdetermined system, i.e., solve the least squares problem: minimize || B - A*X ||.
.PP
# trans = PlasmaNoTrans and M < N: find the minimum norm solution of an underdetermined system A * X = B.
.PP
Several right hand side vectors B and solution vectors X can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.
.PP
PLASMA_zcgels first attempts to factorize the matrix in COMPLEX and use this factorization within an iterative refinement procedure to produce a solution with COMPLEX*16 normwise backward error quality (see below). If the approach fails the method switches to a COMPLEX*16 factorization and solve.
.PP
The iterative refinement is not going to be a winning strategy if the ratio COMPLEX performance over COMPLEX*16 performance is too small. A reasonable strategy should take the number of right-hand sides and the size of the matrix into account. This might be done with a call to ILAENV in the future. Up to now, we always try iterative refinement.
.PP
The iterative refinement process is stopped if ITER > ITERMAX or for all the RHS we have: RNRM < N*XNRM*ANRM*EPS*BWDMAX where:
.PP
.IP "\(bu" 2
ITER is the number of the current iteration in the iterative refinement process
.IP "\(bu" 2
RNRM is the infinity-norm of the residual
.IP "\(bu" 2
XNRM is the infinity-norm of the solution
.IP "\(bu" 2
ANRM is the infinity-operator-norm of the matrix A
.IP "\(bu" 2
EPS is the machine epsilon returned by DLAMCH('Epsilon').
.PP
.PP
Actually, in its current state (PLASMA 2.1.0), the test is slightly relaxed.
.PP
The values ITERMAX and BWDMAX are fixed to 30 and 1.0D+00 respectively.
.PP
We follow Bjorck's algorithm proposed in 'Iterative Refinement of Linear
  Least Squares solutions I', BIT, 7:257-278, 1967.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Intended usage: = PlasmaNoTrans: the linear system involves A; = PlasmaConjTrans: the linear system involves A**H. Currently only PlasmaNoTrans is supported.
.br
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS >= 0.
.br
\fIA\fP The M-by-N matrix A. This matrix is not modified.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIB\fP The M-by-NRHS matrix B of right hand side vectors, stored columnwise. Not modified.
.br
\fILDB\fP The leading dimension of the array B. LDB >= MAX(1,M,N).
.br
\fIX\fP If return value = 0, the solution vectors, stored columnwise. if M >= N, rows 1 to N of X contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of the modulus of elements N+1 to M in that column; if M < N, rows 1 to N of X contain the minimum norm solution vectors;
.br
\fILDX\fP The leading dimension of the array X. LDX >= MAX(1,M,N).
.br
\fIITER\fP The number of the current iteration in the iterative refinement process
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zcgels_Tile\fP 
.PP
\fBPLASMA_zcgels_Tile_Async\fP 
.PP
PLASMA_dsgels 
.PP
\fBPLASMA_zgels\fP 
.RE
.PP

.SS "int PLASMA_zcgesv (intN, intNRHS, PLASMA_Complex64_t *A, intLDA, int *IPIV, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_t *X, intLDX, int *ITER)"PLASMA_zcgesv - Computes the solution to a system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
.PP
PLASMA_zcgesv first attempts to factorize the matrix in COMPLEX and use this factorization within an iterative refinement procedure to produce a solution with COMPLEX*16 normwise backward error quality (see below). If the approach fails the method switches to a COMPLEX*16 factorization and solve.
.PP
The iterative refinement is not going to be a winning strategy if the ratio COMPLEX performance over COMPLEX*16 performance is too small. A reasonable strategy should take the number of right-hand sides and the size of the matrix into account. This might be done with a call to ILAENV in the future. Up to now, we always try iterative refinement.
.PP
The iterative refinement process is stopped if ITER > ITERMAX or for all the RHS we have: RNRM < N*XNRM*ANRM*EPS*BWDMAX where:
.PP
.IP "\(bu" 2
ITER is the number of the current iteration in the iterative refinement process
.IP "\(bu" 2
RNRM is the infinity-norm of the residual
.IP "\(bu" 2
XNRM is the infinity-norm of the solution
.IP "\(bu" 2
ANRM is the infinity-operator-norm of the matrix A
.IP "\(bu" 2
EPS is the machine epsilon returned by DLAMCH('Epsilon').
.PP
.PP
Actually, in its current state (PLASMA 2.1.0), the test is slightly relaxed.
.PP
The values ITERMAX and BWDMAX are fixed to 30 and 1.0D+00 respectively.
.PP
\fBParameters:\fP
.RS 4
\fIN\fP The number of linear equations, i.e., the order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The N-by-N coefficient matrix A. This matrix is not modified.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIIPIV\fP On exit, the pivot indices that define the permutations.
.br
\fIB\fP The N-by-NRHS matrix of right hand side matrix B.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.br
\fIX\fP If return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDX\fP The leading dimension of the array B. LDX >= max(1,N).
.br
\fIITER\fP The number of the current iteration in the iterative refinement process
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zcgesv_Tile\fP 
.PP
\fBPLASMA_zcgesv_Tile_Async\fP 
.PP
\fBPLASMA_dsgesv\fP 
.PP
\fBPLASMA_zgesv\fP 
.RE
.PP

.SS "int PLASMA_zcposv (PLASMA_enumuplo, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_t *X, intLDX, int *ITER)"PLASMA_zcposv - Computes the solution to a system of linear equations A * X = B, where A is an N-by-N symmetric positive definite (or Hermitian positive definite in the complex case) matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as
.PP
A = U**H * U, if uplo = PlasmaUpper, or A = L * L**H, if uplo = PlasmaLower,
.PP
where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.
.PP
PLASMA_zcposv first attempts to factorize the matrix in COMPLEX and use this factorization within an iterative refinement procedure to produce a solution with COMPLEX*16 normwise backward error quality (see below). If the approach fails the method switches to a COMPLEX*16 factorization and solve.
.PP
The iterative refinement is not going to be a winning strategy if the ratio COMPLEX performance over COMPLEX*16 performance is too small. A reasonable strategy should take the number of right-hand sides and the size of the matrix into account. This might be done with a call to ILAENV in the future. Up to now, we always try iterative refinement.
.PP
The iterative refinement process is stopped if ITER > ITERMAX or for all the RHS we have: RNRM < N*XNRM*ANRM*EPS*BWDMAX where:
.PP
.IP "\(bu" 2
ITER is the number of the current iteration in the iterative refinement process
.IP "\(bu" 2
RNRM is the infinity-norm of the residual
.IP "\(bu" 2
XNRM is the infinity-norm of the solution
.IP "\(bu" 2
ANRM is the infinity-operator-norm of the matrix A
.IP "\(bu" 2
EPS is the machine epsilon returned by DLAMCH('Epsilon').
.PP
.PP
Actually, in its current state (PLASMA 2.1.0), the test is slightly relaxed.
.PP
The values ITERMAX and BWDMAX are fixed to 30 and 1.0D+00 respectively.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The number of linear equations, i.e., the order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The N-by-N symmetric positive definite (or Hermitian) coefficient matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. This matrix is not modified.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP The N-by-NRHS matrix of right hand side matrix B.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.br
\fIX\fP If return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDX\fP The leading dimension of the array B. LDX >= max(1,N).
.br
\fIITER\fP The number of the current iteration in the iterative refinement process
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zcposv_Tile\fP 
.PP
\fBPLASMA_zcposv_Tile_Async\fP 
.PP
\fBPLASMA_dsposv\fP 
.PP
\fBPLASMA_zposv\fP 
.RE
.PP

.SS "int PLASMA_zcungesv (PLASMA_enumtrans, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_t *X, intLDX, int *ITER)"PLASMA_zcungesv - Solves overdetermined or underdetermined linear systems involving an M-by-N matrix A using the QR or the LQ factorization of A. It is assumed that A has full rank. The following options are provided:
.PP
# trans = PlasmaNoTrans and M >= N: find the least squares solution of an overdetermined system, i.e., solve the least squares problem: minimize || B - A*X ||.
.PP
# trans = PlasmaNoTrans and M < N: find the minimum norm solution of an underdetermined system A * X = B.
.PP
Several right hand side vectors B and solution vectors X can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.
.PP
PLASMA_zcungesv first attempts to factorize the matrix in COMPLEX and use this factorization within an iterative refinement procedure to produce a solution with COMPLEX*16 normwise backward error quality (see below). If the approach fails the method switches to a COMPLEX*16 factorization and solve.
.PP
The iterative refinement is not going to be a winning strategy if the ratio COMPLEX performance over COMPLEX*16 performance is too small. A reasonable strategy should take the number of right-hand sides and the size of the matrix into account. This might be done with a call to ILAENV in the future. Up to now, we always try iterative refinement.
.PP
The iterative refinement process is stopped if ITER > ITERMAX or for all the RHS we have: RNRM < N*XNRM*ANRM*EPS*BWDMAX where:
.PP
.IP "\(bu" 2
ITER is the number of the current iteration in the iterative refinement process
.IP "\(bu" 2
RNRM is the infinity-norm of the residual
.IP "\(bu" 2
XNRM is the infinity-norm of the solution
.IP "\(bu" 2
ANRM is the infinity-operator-norm of the matrix A
.IP "\(bu" 2
EPS is the machine epsilon returned by DLAMCH('Epsilon').
.PP
.PP
Actually, in its current state (PLASMA 2.1.0), the test is slightly relaxed.
.PP
The values ITERMAX and BWDMAX are fixed to 30 and 1.0D+00 respectively.
.PP
We follow Bjorck's algorithm proposed in 'Iterative Refinement of Linear
  Least Squares solutions I', BIT, 7:257-278, 1967.4
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Intended usage: = PlasmaNoTrans: the linear system involves A; = PlasmaConjTrans: the linear system involves A**H. Currently only PlasmaNoTrans is supported.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS >= 0.
.br
\fIA\fP The M-by-N matrix A. This matrix is not modified.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIB\fP The M-by-NRHS matrix B of right hand side vectors, stored columnwise. Not modified.
.br
\fILDB\fP The leading dimension of the array B. LDB >= MAX(1,M,N).
.br
\fIX\fP If return value = 0, the solution vectors, stored columnwise. if M >= N, rows 1 to N of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of the modulus of elements N+1 to M in that column; if M < N, rows 1 to N of B contain the minimum norm solution vectors;
.br
\fILDX\fP The leading dimension of the array B. LDB >= MAX(1,M,N).
.br
\fIITER\fP The number of the current iteration in the iterative refinement process
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zcungesv_Tile\fP 
.PP
\fBPLASMA_zcungesv_Tile_Async\fP 
.PP
\fBPLASMA_dsungesv\fP 
.PP
\fBPLASMA_zgels\fP 
.RE
.PP

.SS "int PLASMA_zgebrd (PLASMA_enumjobu, PLASMA_enumjobvt, intM, intN, PLASMA_Complex64_t *A, intLDA, double *D, double *E, PLASMA_Complex64_t *U, intLDU, PLASMA_Complex64_t *VT, intLDVT, \fBPLASMA_desc\fP *descT)"PLASMA_zgebrd - computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors. The SVD is written
.PP
A = U * SIGMA * transpose(V)
.PP
where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.
.PP
Note that the routine returns V**T, not V. Not LAPACK Compliant for now! Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIjobu\fP Specifies options for computing all or part of the matrix U. Intended usage: = PlasmaVec: all M columns of U are returned in array U; = PlasmaNoVec: no columns of U (no left singular vectors) are computed. Note: Only PlasmaNoVec supported!
.br
\fIjobvt\fP Specifies options for computing all or part of the matrix V**H. Intended usage: = PlasmaVec: all M columns of U are returned in array U; = PlasmaNoVec: no columns of U (no left singular vectors) are computed. Note: Only PlasmaNoVec supported!
.br
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix A. On exit, if JOBU = 'O', A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise); if JOBVT = 'O', A is overwritten with the first min(m,n) rows of V**H (the right singular vectors, stored rowwise); if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A are destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIS\fP The double precision singular values of A, sorted so that S(i) >= S(i+1).
.br
\fIU\fP (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'. If JOBU = 'A', U contains the M-by-M unitary matrix U; if JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise); if JOBU = 'N' or 'O', U is not referenced.
.br
\fILDU\fP The leading dimension of the array U. LDU >= 1; if JOBU = 'S' or 'A', LDU >= M.
.br
\fIVT\fP If JOBVT = 'A', VT contains the N-by-N unitary matrix V**H; if JOBVT = 'S', VT contains the first min(m,n) rows of V**H (the right singular vectors, stored rowwise); if JOBVT = 'N' or 'O', VT is not referenced.
.br
\fILDVT\fP The leading dimension of the array VT. LDVT >= 1; if JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
.br
\fIdescT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zgesvd On exit, contains auxiliary factorization data.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgebrd_Tile\fP 
.PP
\fBPLASMA_zgebrd_Tile_Async\fP 
.PP
\fBPLASMA_cgebrd\fP 
.PP
\fBPLASMA_dgebrd\fP 
.PP
\fBPLASMA_sgebrd\fP 
.RE
.PP

.SS "int PLASMA_zgelqf (intM, intN, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T)"PLASMA_zgelqf - Computes the tile LQ factorization of a complex M-by-N matrix A: A = L * Q.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix A. On exit, the elements on and below the diagonal of the array contain the m-by-min(M,N) lower trapezoidal matrix L (L is lower triangular if M <= N); the elements above the diagonal represent the unitary matrix Q as a product of elementary reflectors, stored by tiles.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIT\fP On exit, auxiliary factorization data, required by PLASMA_zgelqs to solve the system of equations.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgelqf_Tile\fP 
.PP
\fBPLASMA_zgelqf_Tile_Async\fP 
.PP
\fBPLASMA_cgelqf\fP 
.PP
\fBPLASMA_dgelqf\fP 
.PP
\fBPLASMA_sgelqf\fP 
.PP
\fBPLASMA_zgelqs\fP 
.RE
.PP

.SS "int PLASMA_zgelqs (intM, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgelqs - Compute a minimum-norm solution min || A*X - B || using the LQ factorization A = L*Q computed by PLASMA_zgelqf.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= M >= 0.
.br
\fINRHS\fP The number of columns of B. NRHS >= 0.
.br
\fIA\fP Details of the LQ factorization of the original matrix A as returned by PLASMA_zgelqf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= M.
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgelqf.
.br
\fIB\fP On entry, the M-by-NRHS right hand side matrix B. On exit, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= N.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgelqs_Tile\fP 
.PP
\fBPLASMA_zgelqs_Tile_Async\fP 
.PP
\fBPLASMA_cgelqs\fP 
.PP
\fBPLASMA_dgelqs\fP 
.PP
\fBPLASMA_sgelqs\fP 
.PP
\fBPLASMA_zgelqf\fP 
.RE
.PP

.SS "int PLASMA_zgels (PLASMA_enumtrans, intM, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgels - solves overdetermined or underdetermined linear systems involving an M-by-N matrix A using the QR or the LQ factorization of A. It is assumed that A has full rank. The following options are provided:
.PP
# trans = PlasmaNoTrans and M >= N: find the least squares solution of an overdetermined system, i.e., solve the least squares problem: minimize || B - A*X ||.
.PP
# trans = PlasmaNoTrans and M < N: find the minimum norm solution of an underdetermined system A * X = B.
.PP
Several right hand side vectors B and solution vectors X can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Intended usage: = PlasmaNoTrans: the linear system involves A; = PlasmaConjTrans: the linear system involves A**H. Currently only PlasmaNoTrans is supported.
.br
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS >= 0.
.br
\fIA\fP On entry, the M-by-N matrix A. On exit, if M >= N, A is overwritten by details of its QR factorization as returned by PLASMA_zgeqrf; if M < N, A is overwritten by details of its LQ factorization as returned by PLASMA_zgelqf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIT\fP On exit, auxiliary factorization data.
.br
\fIB\fP On entry, the M-by-NRHS matrix B of right hand side vectors, stored columnwise; On exit, if return value = 0, B is overwritten by the solution vectors, stored columnwise: if M >= N, rows 1 to N of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of the modulus of elements N+1 to M in that column; if M < N, rows 1 to N of B contain the minimum norm solution vectors;
.br
\fILDB\fP The leading dimension of the array B. LDB >= MAX(1,M,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgels_Tile\fP 
.PP
\fBPLASMA_zgels_Tile_Async\fP 
.PP
\fBPLASMA_cgels\fP 
.PP
\fBPLASMA_dgels\fP 
.PP
\fBPLASMA_sgels\fP 
.RE
.PP

.SS "int PLASMA_zgemm (PLASMA_enumtransA, PLASMA_enumtransB, intM, intN, intK, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_tbeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zgemm - Performs one of the matrix-matrix operations
.PP
\[ C = \alpha [op( A )\times op( B )] + \beta C \],
.PP
where op( X ) is one of
.PP
op( X ) = X or op( X ) = X' or op( X ) = conjg( X' )
.PP
alpha and beta are scalars, and A, B and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Specifies whether the matrix A is transposed, not transposed or conjugate transposed: = PlasmaNoTrans: A is not transposed; = PlasmaTrans: A is transposed; = PlasmaConjTrans: A is conjugate transposed.
.br
\fItransB\fP Specifies whether the matrix B is transposed, not transposed or conjugate transposed: = PlasmaNoTrans: B is not transposed; = PlasmaTrans: B is transposed; = PlasmaConjTrans: B is conjugate transposed.
.br
\fIM\fP M specifies the number of rows of the matrix op( A ) and of the matrix C. M >= 0.
.br
\fIN\fP N specifies the number of columns of the matrix op( B ) and of the matrix C. N >= 0.
.br
\fIK\fP K specifies the number of columns of the matrix op( A ) and the number of rows of the matrix op( B ). K >= 0.
.br
\fIalpha\fP alpha specifies the scalar alpha
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is K when transA = PlasmaNoTrans, and is M otherwise.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIB\fP B is a LDB-by-kb matrix, where kb is N when transB = PlasmaNoTrans, and is K otherwise.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.br
\fIbeta\fP beta specifies the scalar beta
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array is overwritten by the M by N matrix ( alpha*op( A )*op( B ) + beta*C )
.br
\fILDC\fP The leading dimension of the array C. LDC >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgemm_Tile\fP 
.PP
\fBPLASMA_cgemm\fP 
.PP
\fBPLASMA_dgemm\fP 
.PP
\fBPLASMA_sgemm\fP 
.RE
.PP

.SS "int PLASMA_zgeqrf (intM, intN, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T)"PLASMA_zgeqrf - Computes the tile QR factorization of a complex M-by-N matrix A: A = Q * R.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix A. On exit, the elements on and above the diagonal of the array contain the min(M,N)-by-N upper trapezoidal matrix R (R is upper triangular if M >= N); the elements below the diagonal represent the unitary matrix Q as a product of elementary reflectors stored by tiles.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIT\fP On exit, auxiliary factorization data, required by PLASMA_zgeqrs to solve the system of equations.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgeqrf_Tile\fP 
.PP
\fBPLASMA_zgeqrf_Tile_Async\fP 
.PP
\fBPLASMA_cgeqrf\fP 
.PP
\fBPLASMA_dgeqrf\fP 
.PP
\fBPLASMA_sgeqrf\fP 
.PP
\fBPLASMA_zgeqrs\fP 
.RE
.PP

.SS "int PLASMA_zgeqrs (intM, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgeqrs - Compute a minimum-norm solution min || A*X - B || using the RQ factorization A = R*Q computed by PLASMA_zgeqrf.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= M >= 0.
.br
\fINRHS\fP The number of columns of B. NRHS >= 0.
.br
\fIA\fP Details of the QR factorization of the original matrix A as returned by PLASMA_zgeqrf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= M.
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgeqrf.
.br
\fIB\fP On entry, the m-by-nrhs right hand side matrix B. On exit, the n-by-nrhs solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgeqrs_Tile\fP 
.PP
\fBPLASMA_zgeqrs_Tile_Async\fP 
.PP
\fBPLASMA_cgeqrs\fP 
.PP
\fBPLASMA_dgeqrs\fP 
.PP
\fBPLASMA_sgeqrs\fP 
.PP
\fBPLASMA_zgeqrf\fP 
.RE
.PP

.SS "int PLASMA_zgesv (intN, intNRHS, PLASMA_Complex64_t *A, intLDA, int *IPIV, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgesv - Computes the solution to a system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. The tile LU decomposition with partial tile pivoting and row interchanges is used to factor A. The factored form of A is then used to solve the system of equations A * X = B.
.PP
\fBParameters:\fP
.RS 4
\fIN\fP The number of linear equations, i.e., the order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP On entry, the N-by-N coefficient matrix A. On exit, the tile L and U factors from the factorization.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIIPIV\fP On exit, the pivot indices that define the permutations.
.br
\fIB\fP On entry, the N-by-NRHS matrix of right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgesv_Tile\fP 
.PP
\fBPLASMA_zgesv_Tile_Async\fP 
.PP
\fBPLASMA_cgesv\fP 
.PP
\fBPLASMA_dgesv\fP 
.PP
\fBPLASMA_sgesv\fP 
.RE
.PP

.SS "int PLASMA_zgesv_incpiv (intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgesv_incpiv - Computes the solution to a system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. The tile LU decomposition with partial tile pivoting and row interchanges is used to factor A. The factored form of A is then used to solve the system of equations A * X = B.
.PP
\fBParameters:\fP
.RS 4
\fIN\fP The number of linear equations, i.e., the order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP On entry, the N-by-N coefficient matrix A. On exit, the tile L and U factors from the factorization (not equivalent to LAPACK).
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIL\fP On exit, auxiliary factorization data, related to the tile L factor, necessary to solve the system of equations.
.br
\fIIPIV\fP On exit, the pivot indices that define the permutations (not equivalent to LAPACK).
.br
\fIB\fP On entry, the N-by-NRHS matrix of right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgesv_incpiv_Tile\fP 
.PP
\fBPLASMA_zgesv_incpiv_Tile_Async\fP 
.PP
\fBPLASMA_cgesv_incpiv\fP 
.PP
\fBPLASMA_dgesv_incpiv\fP 
.PP
\fBPLASMA_sgesv_incpiv\fP 
.RE
.PP

.SS "int PLASMA_zgesvd (PLASMA_enumjobu, PLASMA_enumjobvt, intM, intN, PLASMA_Complex64_t *A, intLDA, double *S, PLASMA_Complex64_t *U, intLDU, PLASMA_Complex64_t *VT, intLDVT, \fBPLASMA_desc\fP *descT)"PLASMA_zgesvd - computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors. The SVD is written
.PP
A = U * SIGMA * transpose(V)
.PP
where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.
.PP
Note that the routine returns V**T, not V. Not LAPACK Compliant for now! Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIjobu\fP Specifies options for computing all or part of the matrix U. Intended usage: = PlasmaVec: all M columns of U are returned in array U; = PlasmaNoVec: no columns of U (no left singular vectors) are computed. Note: Only PlasmaNoVec supported!
.br
\fIjobvt\fP Specifies options for computing all or part of the matrix V**H. Intended usage: = PlasmaVec: all M columns of U are returned in array U; = PlasmaNoVec: no columns of U (no left singular vectors) are computed. Note: Only PlasmaNoVec supported!
.br
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix A. On exit, if JOBU = 'O', A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise); if JOBVT = 'O', A is overwritten with the first min(m,n) rows of V**H (the right singular vectors, stored rowwise); if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A are destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIS\fP The double precision singular values of A, sorted so that S(i) >= S(i+1).
.br
\fIU\fP (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'. If JOBU = 'A', U contains the M-by-M unitary matrix U; if JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise); if JOBU = 'N' or 'O', U is not referenced.
.br
\fILDU\fP The leading dimension of the array U. LDU >= 1; if JOBU = 'S' or 'A', LDU >= M.
.br
\fIVT\fP If JOBVT = 'A', VT contains the N-by-N unitary matrix V**H; if JOBVT = 'S', VT contains the first min(m,n) rows of V**H (the right singular vectors, stored rowwise); if JOBVT = 'N' or 'O', VT is not referenced.
.br
\fILDVT\fP The leading dimension of the array VT. LDVT >= 1; if JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
.br
\fIdescT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zgesvd On exit, contains auxiliary factorization data.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgesvd_Tile\fP 
.PP
\fBPLASMA_zgesvd_Tile_Async\fP 
.PP
\fBPLASMA_cgesvd\fP 
.PP
\fBPLASMA_dgesvd\fP 
.PP
\fBPLASMA_sgesvd\fP 
.RE
.PP

.SS "int PLASMA_zgetrf (intM, intN, PLASMA_Complex64_t *A, intLDA, int *IPIV)"PLASMA_zgetrf - Computes an LU factorization of a general M-by-N matrix A using the tile LU algorithm with partial tile pivoting with row interchanges.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix to be factored. On exit, the tile factors L and U from the factorization.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIIPIV\fP The pivot indices that define the permutations.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgetrf_Tile\fP 
.PP
\fBPLASMA_zgetrf_Tile_Async\fP 
.PP
\fBPLASMA_cgetrf\fP 
.PP
\fBPLASMA_dgetrf\fP 
.PP
\fBPLASMA_sgetrf\fP 
.RE
.PP

.SS "int PLASMA_zgetrf_incpiv (intM, intN, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *L, int *IPIV)"PLASMA_zgetrf_incpiv - Computes an LU factorization of a general M-by-N matrix A using the tile LU algorithm with partial tile pivoting with row interchanges.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix A. M >= 0.
.br
\fIN\fP The number of columns of the matrix A. N >= 0.
.br
\fIA\fP On entry, the M-by-N matrix to be factored. On exit, the tile factors L and U from the factorization.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIL\fP On exit, auxiliary factorization data, related to the tile L factor, required by PLASMA_zgetrs_incpiv to solve the system of equations.
.br
\fIIPIV\fP The pivot indices that define the permutations (not equivalent to LAPACK).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgetrf_incpiv_Tile\fP 
.PP
\fBPLASMA_zgetrf_incpiv_Tile_Async\fP 
.PP
\fBPLASMA_cgetrf_incpiv\fP 
.PP
\fBPLASMA_dgetrf_incpiv\fP 
.PP
\fBPLASMA_sgetrf_incpiv\fP 
.PP
\fBPLASMA_zgetrs_incpiv\fP 
.RE
.PP

.SS "int PLASMA_zgetrs (PLASMA_enumtrans, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, int *IPIV, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgetrs - Solves a system of linear equations A * X = B, with a general N-by-N matrix A using the tile LU factorization computed by PLASMA_zgetrf.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Intended to specify the the form of the system of equations: = PlasmaNoTrans: A * X = B (No transpose) = PlasmaTrans: A**T * X = B (Transpose) = PlasmaConjTrans: A**H * X = B (Conjugate transpose)
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The tile factors L and U from the factorization, computed by PLASMA_zgetrf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIIPIV\fP The pivot indices from PLASMA_zgetrf.
.br
\fIB\fP On entry, the N-by-NRHS matrix of right hand side matrix B. On exit, the solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.RE
.PP
\fBReturns:\fP
.RS 4
<0 if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgetrs_Tile\fP 
.PP
\fBPLASMA_zgetrs_Tile_Async\fP 
.PP
\fBPLASMA_cgetrs\fP 
.PP
\fBPLASMA_dgetrs\fP 
.PP
\fBPLASMA_sgetrs\fP 
.PP
\fBPLASMA_zgetrf\fP 
.RE
.PP

.SS "int PLASMA_zgetrs_incpiv (PLASMA_enumtrans, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, intLDB)"PLASMA_zgetrs_incpiv - Solves a system of linear equations A * X = B, with a general N-by-N matrix A using the tile LU factorization computed by PLASMA_zgetrf_incpiv.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Intended to specify the the form of the system of equations: = PlasmaNoTrans: A * X = B (No transpose) = PlasmaTrans: A**T * X = B (Transpose) = PlasmaConjTrans: A**H * X = B (Conjugate transpose) Currently only PlasmaNoTrans is supported.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The tile factors L and U from the factorization, computed by PLASMA_zgetrf_incpiv.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIL\fP Auxiliary factorization data, related to the tile L factor, computed by PLASMA_zgetrf_incpiv.
.br
\fIIPIV\fP The pivot indices from PLASMA_zgetrf_incpiv (not equivalent to LAPACK).
.br
\fIB\fP On entry, the N-by-NRHS matrix of right hand side matrix B. On exit, the solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.RE
.PP
\fBReturns:\fP
.RS 4
<0 if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zgetrs_incpiv_Tile\fP 
.PP
\fBPLASMA_zgetrs_incpiv_Tile_Async\fP 
.PP
\fBPLASMA_cgetrs_incpiv\fP 
.PP
\fBPLASMA_dgetrs_incpiv\fP 
.PP
\fBPLASMA_sgetrs_incpiv\fP 
.PP
\fBPLASMA_zgetrf_incpiv\fP 
.RE
.PP

.SS "int PLASMA_zheev (PLASMA_enumjobz, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, double *W, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zheev - Computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. The matrix A is preliminary reduced to tridiagonal form using a two-stage approach: First stage: reduction to band tridiagonal form; Second stage: reduction from band to tridiagonal form. Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIjobz\fP Intended usage: = PlasmaNoVec: computes eigenvalues only; = PlasmaVec: computes eigenvalues and eigenvectors. Note: Only PlasmaNoVec supported!
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the symmetric (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, the lower triangle (if uplo = PlasmaLower) or the upper triangle (if uplo = PlasmaUpper) of A, including the diagonal, is destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIW\fP On exit, if info = 0, the eigenvalues.
.br
\fIdescT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zheev On exit, contains auxiliary factorization data.
.br
\fIQ\fP On exit, if jobz = PlasmaVec and info = 0, the eigenvectors.
.br
\fILDQ\fP The leading dimension of the array Q. LDQ >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zheev_Tile\fP 
.PP
\fBPLASMA_zheev_Tile_Async\fP 
.PP
\fBPLASMA_cheev\fP 
.PP
\fBPLASMA_dsyev\fP 
.PP
\fBPLASMA_ssyev\fP 
.RE
.PP

.SS "int PLASMA_zheevd (PLASMA_enumjobz, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, double *W, \fBPLASMA_desc\fP *T, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zheevd - Computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. The matrix A is preliminary reduced to tridiagonal form using a two-stage approach: First stage: reduction to band tridiagonal form; Second stage: reduction from band to tridiagonal form. Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIjobz\fP Intended usage: = PlasmaNoVec: computes eigenvalues only; = PlasmaVec: computes eigenvalues and eigenvectors. Note: Only PlasmaNoVec supported!
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the symmetric (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, the lower triangle (if uplo = PlasmaLower) or the upper triangle (if uplo = PlasmaUpper) of A, including the diagonal, is destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIW\fP On exit, if info = 0, the eigenvalues.
.br
\fIT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zheev On exit, contains auxiliary factorization data.
.br
\fIQ\fP On exit, if jobz = PlasmaVec and info = 0, the eigenvectors.
.br
\fILDQ\fP The leading dimension of the array Q. LDQ >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zheevd_Tile\fP 
.PP
\fBPLASMA_zheevd_Tile_Async\fP 
.PP
PLASMA_cheevd 
.PP
PLASMA_dsyevd 
.PP
PLASMA_ssyevd 
.RE
.PP

.SS "int PLASMA_zhegst (PLASMA_enumitype, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB)"PLASMA_zhegst - reduces a complex Hermitian-definite generalized eigenproblem to standard form. If PlasmaItype == 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H) If PlasmaItype == 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L. B must have been previously factorized as U**H*U or L*L**H by PLASMA_ZPOTRF.
.PP
\fBParameters:\fP
.RS 4
\fIPlasmaItype\fP Intended usage: = 1: A*x=(lambda)*B*x = 2: A*Bx=(lambda)*x = 3: B*A*x=(lambda)*x
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrices A and B. N >= 0.
.br
\fIA\fP On entry, the symmetric (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value == 0, the transformed matrix, stored in the same format as A.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the triangular factor from the Cholesky factorization of B, as returned by PLASMA_ZPOTRF.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zhegst_Tile\fP 
.PP
\fBPLASMA_zhegst_Tile_Async\fP 
.PP
\fBPLASMA_chegst\fP 
.PP
\fBPLASMA_dsygst\fP 
.PP
\fBPLASMA_ssygst\fP 
.RE
.PP

.SS "int PLASMA_zhegv (PLASMA_enumitype, PLASMA_enumjobz, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, double *W, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zhegv - Computes all eigenvalues and, optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem of the form: A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian and B is also positive definite. Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIPlasmaItype\fP Intended usage: = 1: A*x=(lambda)*B*x = 2: A*Bx=(lambda)*x = 3: B*A*x=(lambda)*x
.br
\fIjobz\fP Intended usage: = PlasmaNoVec: computes eigenvalues only; = PlasmaVec: computes eigenvalues and eigenvectors. Note: Only PlasmaNoVec supported!
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A and B are stored; = PlasmaLower: Lower triangle of A and B are stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the symmetric (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if jobz = PlasmaVec, then if return value = 0, A contains the matrix Z of eigenvectors. The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**H*B*Z = I; if ITYPE = 3, Z**H*inv(B)*Z = I. If jobz = PlasmaNoVec, then on exit the lower triangle (if uplo = PlasmaLower) or the upper triangle (if uplo = PlasmaUpper) of A, including the diagonal, is destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the symmetric (or Hermitian) positive definite matrix B. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B, and the strictly lower triangular part of B is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B, and the strictly upper triangular part of B is not referenced. On exit, if return value <= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the Cholesky factorization B = U**H*U or B = L*L**H.
.br
\fILDB\fP The leading dimension of the array B. LDA >= max(1,N).
.br
\fIW\fP On exit, if info = 0, the eigenvalues.
.br
\fIdescT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zhegv On exit, contains auxiliary factorization data.
.br
\fIQ\fP On exit, if jobz = PlasmaVec and info = 0, the eigenvectors.
.br
\fILDQ\fP The leading dimension of Q.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI<=N\fP if INFO = i, plasma_zhegv failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero. 
.br
\fI>N\fP if INFO = N + i, for 1 <= i <= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zhegv_Tile\fP 
.PP
\fBPLASMA_zhegv_Tile_Async\fP 
.PP
\fBPLASMA_chegv\fP 
.PP
\fBPLASMA_dsygv\fP 
.PP
\fBPLASMA_ssygv\fP 
.RE
.PP

.SS "int PLASMA_zhemm (PLASMA_enumside, PLASMA_enumuplo, intM, intN, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_tbeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zhemm - Performs one of the matrix-matrix operations
.PP
\[ C = \alpha \times A \times B + \beta \times C \].PP
or
.PP
\[ C = \alpha \times B \times A + \beta \times C \].PP
where alpha and beta are scalars, A is an hermitian matrix and B and C are m by n matrices.
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Specifies whether the hermitian matrix A appears on the left or right in the operation as follows: = PlasmaLeft: \[ C = \alpha \times A \times B + \beta \times C \] = PlasmaRight: \[ C = \alpha \times B \times A + \beta \times C \]
.br
\fIuplo\fP Specifies whether the upper or lower triangular part of the hermitian matrix A is to be referenced as follows: = PlasmaLower: Only the lower triangular part of the hermitian matrix A is to be referenced. = PlasmaUpper: Only the upper triangular part of the hermitian matrix A is to be referenced.
.br
\fIM\fP Specifies the number of rows of the matrix C. M >= 0.
.br
\fIN\fP Specifies the number of columns of the matrix C. N >= 0.
.br
\fIalpha\fP Specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is M when side = PlasmaLeft, and is N otherwise. Only the uplo triangular part is referenced.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,ka).
.br
\fIB\fP B is a LDB-by-N matrix, where the leading M-by-N part of the array B must contain the matrix B.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,M).
.br
\fIbeta\fP Specifies the scalar beta.
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array is overwritten by the M by N updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zhemm_Tile\fP 
.PP
\fBPLASMA_chemm\fP 
.PP
PLASMA_dhemm 
.PP
PLASMA_shemm 
.RE
.PP

.SS "int PLASMA_zher2k (PLASMA_enumuplo, PLASMA_enumtrans, intN, intK, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, doublebeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zher2k - Performs one of the hermitian rank 2k operations
.PP
\[ C = \alpha [ op( A ) \times conjg( op( B )' )] + conjg( \alpha ) [ op( B ) \times conjg( op( A )' )] + \beta C \], or \[ C = \alpha [ conjg( op( A )' ) \times op( B ) ] + conjg( \alpha ) [ conjg( op( B )' ) \times op( A ) ] + \beta C \],
.PP
where op( X ) is one of
.PP
op( X ) = X or op( X ) = conjg( X' )
.PP
where alpha and beta are real scalars, C is an n-by-n symmetric matrix and A and B are an n-by-k matrices the first case and k-by-n matrices in the second case.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of C is stored; = PlasmaLower: Lower triangle of C is stored.
.br
\fItrans\fP Specifies whether the matrix A is transposed or conjugate transposed: = PlasmaNoTrans: \[ C = \alpha [ op( A ) \times conjg( op( B )' )] + conjg( \alpha ) [ op( B ) \times conjg( op( A )' )] + \beta C \] = PlasmaConjTrans: \[ C = \alpha [ conjg( op( A )' ) \times op( B ) ] + conjg( \alpha ) [ conjg( op( B )' ) \times op( A ) ] + \beta C \]
.br
\fIN\fP N specifies the order of the matrix C. N must be at least zero.
.br
\fIK\fP K specifies the number of columns of the A and B matrices with trans = PlasmaNoTrans. K specifies the number of rows of the A and B matrices with trans = PlasmaTrans.
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDA\fP The leading dimension of the array A. LDA must be at least max( 1, N ), otherwise LDA must be at least max( 1, K ).
.br
\fIB\fP B is a LDB-by-kb matrix, where kb is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDB\fP The leading dimension of the array B. LDB must be at least max( 1, N ), otherwise LDB must be at least max( 1, K ).
.br
\fIbeta\fP beta specifies the scalar beta.
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max( 1, N ).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zher2k_Tile\fP 
.PP
\fBPLASMA_cher2k\fP 
.PP
PLASMA_dher2k 
.PP
PLASMA_sher2k 
.RE
.PP

.SS "int PLASMA_zherk (PLASMA_enumuplo, PLASMA_enumtrans, intN, intK, doublealpha, PLASMA_Complex64_t *A, intLDA, doublebeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zherk - Performs one of the hermitian rank k operations
.PP
\[ C = \alpha [ op( A ) \times conjg( op( A )' )] + \beta C \],
.PP
where op( X ) is one of
.PP
op( X ) = X or op( X ) = conjg( X' )
.PP
where alpha and beta are real scalars, C is an n-by-n hermitian matrix and A is an n-by-k matrix in the first case and a k-by-n matrix in the second case.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of C is stored; = PlasmaLower: Lower triangle of C is stored.
.br
\fItrans\fP Specifies whether the matrix A is transposed or conjugate transposed: = PlasmaNoTrans: A is not transposed; = PlasmaConjTrans: A is conjugate transposed.
.br
\fIN\fP N specifies the order of the matrix C. N must be at least zero.
.br
\fIK\fP K specifies the number of columns of the matrix op( A ).
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDA\fP The leading dimension of the array A. LDA must be at least max( 1, N ), otherwise LDA must be at least max( 1, K ).
.br
\fIbeta\fP beta specifies the scalar beta
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max( 1, N ).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zherk_Tile\fP 
.PP
\fBPLASMA_cherk\fP 
.PP
PLASMA_dherk 
.PP
PLASMA_sherk 
.RE
.PP

.SS "int PLASMA_zhetrd (PLASMA_enumjobz, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, double *D, double *E, \fBPLASMA_desc\fP *descT, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zhetrd - reduces a complex Hermitian matrix A to real symmetric tridiagonal form S using a two-stage approach First stage: reduction to band tridiagonal form (unitary Q1); Second stage: reduction from band to tridiagonal form (unitary Q2). Let Q = Q1 * Q2 be the global unitary transformation; Q**H * A * Q = S. Not LAPACK compliant as A does not contain the T elements Note: Only PlasmaNoVec supported!
.PP
\fBParameters:\fP
.RS 4
\fIjobz\fP Intended usage: = PlasmaNoVec: computes eigenvalues only; = PlasmaVec: computes eigenvalues and eigenvectors. Note: Only PlasmaNoVec supported!
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the symmetric (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, the lower triangle (if uplo = PlasmaLower) or the upper triangle (if uplo = PlasmaUpper) of A, including the diagonal, is destroyed.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fID\fP On exit, the diagonal elements of the tridiagonal matrix: D(i) = A(i,i).
.br
\fIE\fP On exit, he off-diagonal elements of the tridiagonal matrix: E(i) = A(i,i+1) if uplo = PlasmaUpper, E(i) = A(i+1,i) if uplo = PlasmaLower.
.br
\fIdescT\fP On entry, descriptor as return by PLASMA_Alloc_Workspace_zheev On exit, contains auxiliary factorization data.
.br
\fIQ\fP On exit, if jobz = PlasmaVec and info = 0, the eigenvectors.
.br
\fILDQ\fP The leading dimension of the array Q. LDQ >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if INFO = i, the algorithm failed to converge; i off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zhetrd_Tile\fP 
.PP
\fBPLASMA_zhetrd_Tile_Async\fP 
.PP
\fBPLASMA_chetrd\fP 
.PP
\fBPLASMA_dsytrd\fP 
.PP
\fBPLASMA_ssytrd\fP 
.RE
.PP

.SS "double PLASMA_zlange (PLASMA_enumnorm, intM, intN, PLASMA_Complex64_t *A, intLDA, double *work)"PLASMA_zlange returns the value
.PP
zlange = ( max(abs(A(i,j))), NORM = PlasmaMaxNorm ( ( norm1(A), NORM = PlasmaOneNorm ( ( normI(A), NORM = PlasmaInfNorm ( ( normF(A), NORM = PlasmaFrobeniusNorm
.PP
where norm1 denotes the one norm of a matrix (maximum column sum), normI denotes the infinity norm of a matrix (maximum row sum) and normF denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(A(i,j))) is not a consistent matrix norm.
.PP
\fBParameters:\fP
.RS 4
\fInorm\fP = PlasmaMaxNorm: Max norm = PlasmaOneNorm: One norm = PlasmaInfNorm: Infinity norm = PlasmaFrobeniusNorm: Frobenius norm
.br
\fIM\fP The number of rows of the matrix A. M >= 0. When M = 0, the returned value is set to zero.
.br
\fIN\fP The number of columns of the matrix A. N >= 0. When N = 0, the returned value is set to zero.
.br
\fIA\fP The M-by-N matrix A.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIwork\fP double precision array of dimension (MAX(1,LWORK)), where LWORK >= M when NORM = PlasmaInfNorm; otherwise, WORK is not referenced.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIthe\fP norm described above.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zlange_Tile\fP 
.PP
\fBPLASMA_zlange_Tile_Async\fP 
.PP
\fBPLASMA_clange\fP 
.PP
\fBPLASMA_dlange\fP 
.PP
\fBPLASMA_slange\fP 
.RE
.PP

.SS "double PLASMA_zlanhe (PLASMA_enumnorm, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, double *work)"PLASMA_zlanhe returns the value
.PP
zlanhe = ( max(abs(A(i,j))), NORM = PlasmaMaxNorm ( ( norm1(A), NORM = PlasmaOneNorm ( ( normI(A), NORM = PlasmaInfNorm ( ( normF(A), NORM = PlasmaFrobeniusNorm
.PP
where norm1 denotes the one norm of a matrix (maximum column sum), normI denotes the infinity norm of a matrix (maximum row sum) and normF denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(A(i,j))) is not a consistent matrix norm.
.PP
\fBParameters:\fP
.RS 4
\fInorm\fP = PlasmaMaxNorm: Max norm = PlasmaOneNorm: One norm = PlasmaInfNorm: Infinity norm = PlasmaFrobeniusNorm: Frobenius norm
.br
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The number of columns/rows of the matrix A. N >= 0. When N = 0, the returned value is set to zero.
.br
\fIA\fP The N-by-N matrix A.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIwork\fP double precision array of dimension PLASMA_SIZE is PLASMA_STATIC_SCHEDULING is used, and NULL otherwise.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIthe\fP norm described above.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zlanhe_Tile\fP 
.PP
\fBPLASMA_zlanhe_Tile_Async\fP 
.PP
\fBPLASMA_clanhe\fP 
.PP
PLASMA_dlanhe 
.PP
PLASMA_slanhe 
.RE
.PP

.SS "double PLASMA_zlansy (PLASMA_enumnorm, PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA, double *work)"PLASMA_zlansy returns the value
.PP
zlansy = ( max(abs(A(i,j))), NORM = PlasmaMaxNorm ( ( norm1(A), NORM = PlasmaOneNorm ( ( normI(A), NORM = PlasmaInfNorm ( ( normF(A), NORM = PlasmaFrobeniusNorm
.PP
where norm1 denotes the one norm of a matrix (maximum column sum), normI denotes the infinity norm of a matrix (maximum row sum) and normF denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(A(i,j))) is not a consistent matrix norm.
.PP
\fBParameters:\fP
.RS 4
\fInorm\fP = PlasmaMaxNorm: Max norm = PlasmaOneNorm: One norm = PlasmaInfNorm: Infinity norm = PlasmaFrobeniusNorm: Frobenius norm
.br
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The number of columns/rows of the matrix A. N >= 0. When N = 0, the returned value is set to zero.
.br
\fIA\fP The N-by-N matrix A.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIwork\fP double precision array of dimension PLASMA_SIZE is PLASMA_STATIC_SCHEDULING is used, and NULL otherwise.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIthe\fP norm described above.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zlansy_Tile\fP 
.PP
\fBPLASMA_zlansy_Tile_Async\fP 
.PP
\fBPLASMA_clansy\fP 
.PP
\fBPLASMA_dlansy\fP 
.PP
\fBPLASMA_slansy\fP 
.RE
.PP

.SS "int PLASMA_zLapack_to_Tile (PLASMA_Complex64_t *Af77, intLDA, \fBPLASMA_desc\fP *A)"PLASMA_zLapack_to_Tile - Conversion from LAPACK layout to tile layout.
.PP
\fBParameters:\fP
.RS 4
\fIAf77\fP LAPACK matrix.
.br
\fILDA\fP The leading dimension of the matrix Af77.
.br
\fIA\fP Descriptor of the PLASMA matrix in tile layout. If PLASMA_TRANSLATION_MODE is set to PLASMA_INPLACE, A->mat is not used and set to Af77 when returns, else if PLASMA_TRANSLATION_MODE is set to PLASMA_OUTOFPLACE, A->mat has to be allocated before.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zLapack_to_Tile_Async\fP 
.PP
\fBPLASMA_zTile_to_Lapack\fP 
.PP
\fBPLASMA_cLapack_to_Tile\fP 
.PP
\fBPLASMA_dLapack_to_Tile\fP 
.PP
\fBPLASMA_sLapack_to_Tile\fP 
.RE
.PP

.SS "int PLASMA_zlaswp (intN, PLASMA_Complex64_t *A, intLDA, intK1, intK2, int *IPIV, intINCX)"PLASMA_zlaswp - performs a series of row interchanges on the matrix A. One row interchange is initiated for each of rows K1 through K2 of A.
.PP
\fBParameters:\fP
.RS 4
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP The tile factors L and U from the factorization, computed by PLASMA_zgetrf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIK1\fP The first element of IPIV for which a row interchange will be done.
.br
\fIK2\fP The last element of IPIV for which a row interchange will be done.
.br
\fIIPIV\fP The pivot indices from PLASMA_zgetrf.
.br
\fIINCX\fP The increment between successive values of IPIV. If IPIV is negative, the pivots are applied in reverse order.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.RE
.PP
\fBReturns:\fP
.RS 4
<0 if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zlaswp_Tile\fP 
.PP
\fBPLASMA_zlaswp_Tile_Async\fP 
.PP
\fBPLASMA_claswp\fP 
.PP
\fBPLASMA_dlaswp\fP 
.PP
\fBPLASMA_slaswp\fP 
.PP
\fBPLASMA_zgetrf\fP 
.RE
.PP

.SS "int PLASMA_zlauum (PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA)"PLASMA_zlauum - Computes the product U * U' or L' * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A.
.PP
If UPLO = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A. If UPLO = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the triangular factor U or L. N >= 0.
.br
\fIA\fP On entry, the triangular factor U or L. On exit, if UPLO = 'U', the upper triangle of A is overwritten with the upper triangle of the product U * U'; if UPLO = 'L', the lower triangle of A is overwritten with the lower triangle of the product L' * L.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zlauum_Tile\fP 
.PP
\fBPLASMA_zlauum_Tile_Async\fP 
.PP
\fBPLASMA_clauum\fP 
.PP
\fBPLASMA_dlauum\fP 
.PP
\fBPLASMA_slauum\fP 
.PP
\fBPLASMA_zpotri\fP 
.RE
.PP

.SS "int PLASMA_zplghe (doublebump, intN, PLASMA_Complex64_t *A, intLDA, unsigned long long intseed)"PLASMA_zplghe - Generate a random hermitian matrix by tiles.
.PP
\fBParameters:\fP
.RS 4
\fIbump\fP The value to add to the diagonal to be sure to have a positive definite matrix.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On exit, The random hermitian matrix A generated.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIseed\fP The seed used in the random generation.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zplghe_Tile\fP 
.PP
\fBPLASMA_zplghe_Tile_Async\fP 
.PP
\fBPLASMA_cplghe\fP 
.PP
PLASMA_dplghe 
.PP
PLASMA_splghe 
.PP
\fBPLASMA_zplrnt\fP 
.PP
\fBPLASMA_zplgsy\fP 
.RE
.PP

.SS "int PLASMA_zplgsy (PLASMA_Complex64_tbump, intN, PLASMA_Complex64_t *A, intLDA, unsigned long long intseed)"PLASMA_zplgsy - Generate a random hermitian matrix by tiles.
.PP
\fBParameters:\fP
.RS 4
\fIbump\fP The value to add to the diagonal to be sure to have a positive definite matrix.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On exit, The random hermitian matrix A generated.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIseed\fP The seed used in the random generation.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zplgsy_Tile\fP 
.PP
\fBPLASMA_zplgsy_Tile_Async\fP 
.PP
\fBPLASMA_cplgsy\fP 
.PP
\fBPLASMA_dplgsy\fP 
.PP
\fBPLASMA_splgsy\fP 
.PP
\fBPLASMA_zplrnt\fP 
.PP
\fBPLASMA_zplgsy\fP 
.RE
.PP

.SS "int PLASMA_zplrnt (intM, intN, PLASMA_Complex64_t *A, intLDA, unsigned long long intseed)"PLASMA_zplrnt - Generate a random matrix by tiles.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of A.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On exit, The random matrix A generated.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIseed\fP The seed used in the random generation.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zplrnt_Tile\fP 
.PP
\fBPLASMA_zplrnt_Tile_Async\fP 
.PP
\fBPLASMA_cplrnt\fP 
.PP
\fBPLASMA_dplrnt\fP 
.PP
\fBPLASMA_splrnt\fP 
.PP
\fBPLASMA_zplghe\fP 
.PP
\fBPLASMA_zplgsy\fP 
.RE
.PP

.SS "int PLASMA_zposv (PLASMA_enumuplo, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB)"PLASMA_zposv - Computes the solution to a system of linear equations A * X = B, where A is an N-by-N symmetric positive definite (or Hermitian positive definite in the complex case) matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as
.PP
\[ A = \{_{L\times L^H, if uplo = PlasmaLower}^{U^H\times U, if uplo = PlasmaUpper} \].PP
where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The number of linear equations, i.e., the order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP On entry, the symmetric positive definite (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value = 0, the factor U or L from the Cholesky factorization A = U**H*U or A = L*L**H.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the N-by-NRHS right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zposv_Tile\fP 
.PP
\fBPLASMA_zposv_Tile_Async\fP 
.PP
\fBPLASMA_cposv\fP 
.PP
\fBPLASMA_dposv\fP 
.PP
\fBPLASMA_sposv\fP 
.RE
.PP

.SS "int PLASMA_zpotrf (PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA)"PLASMA_zpotrf - Computes the Cholesky factorization of a symmetric positive definite (or Hermitian positive definite in the complex case) matrix A. The factorization has the form
.PP
\[ A = \{_{L\times L^H, if uplo = PlasmaLower}^{U^H\times U, if uplo = PlasmaUpper} \].PP
where U is an upper triangular matrix and L is a lower triangular matrix.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the symmetric positive definite (or Hermitian) matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value = 0, the factor U or L from the Cholesky factorization A = U**H*U or A = L*L**H.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zpotrf_Tile\fP 
.PP
\fBPLASMA_zpotrf_Tile_Async\fP 
.PP
\fBPLASMA_cpotrf\fP 
.PP
\fBPLASMA_dpotrf\fP 
.PP
\fBPLASMA_spotrf\fP 
.PP
\fBPLASMA_zpotrs\fP 
.RE
.PP

.SS "int PLASMA_zpotri (PLASMA_enumuplo, intN, PLASMA_Complex64_t *A, intLDA)"PLASMA_zpotri - Computes the inverse of a complex Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by PLASMA_zpotrf.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the triangular factor U or L from the Cholesky factorization A = U**H*U or A = L*L**H, as computed by PLASMA_zpotrf. On exit, the upper or lower triangle of the (Hermitian) inverse of A, overwriting the input factor U or L.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, the (i,i) element of the factor U or L is zero, and the inverse could not be computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zpotri_Tile\fP 
.PP
\fBPLASMA_zpotri_Tile_Async\fP 
.PP
\fBPLASMA_cpotri\fP 
.PP
\fBPLASMA_dpotri\fP 
.PP
\fBPLASMA_spotri\fP 
.PP
\fBPLASMA_zpotrf\fP 
.RE
.PP

.SS "int PLASMA_zpotrs (PLASMA_enumuplo, intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB)"PLASMA_zpotrs - Solves a system of linear equations A * X = B with a symmetric positive definite (or Hermitian positive definite in the complex case) matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by PLASMA_zpotrf.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The triangular factor U or L from the Cholesky factorization A = U**H*U or A = L*L**H, computed by PLASMA_zpotrf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the N-by-NRHS right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zpotrs_Tile\fP 
.PP
\fBPLASMA_zpotrs_Tile_Async\fP 
.PP
\fBPLASMA_cpotrs\fP 
.PP
\fBPLASMA_dpotrs\fP 
.PP
\fBPLASMA_spotrs\fP 
.PP
\fBPLASMA_zpotrf\fP 
.RE
.PP

.SS "int PLASMA_zsymm (PLASMA_enumside, PLASMA_enumuplo, intM, intN, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_tbeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zsymm - Performs one of the matrix-matrix operations
.PP
\[ C = \alpha \times A \times B + \beta \times C \].PP
or
.PP
\[ C = \alpha \times B \times A + \beta \times C \].PP
where alpha and beta are scalars, A is an symmetric matrix and B and C are m by n matrices.
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Specifies whether the symmetric matrix A appears on the left or right in the operation as follows: = PlasmaLeft: \[ C = \alpha \times A \times B + \beta \times C \] = PlasmaRight: \[ C = \alpha \times B \times A + \beta \times C \]
.br
\fIuplo\fP Specifies whether the upper or lower triangular part of the symmetric matrix A is to be referenced as follows: = PlasmaLower: Only the lower triangular part of the symmetric matrix A is to be referenced. = PlasmaUpper: Only the upper triangular part of the symmetric matrix A is to be referenced.
.br
\fIM\fP Specifies the number of rows of the matrix C. M >= 0.
.br
\fIN\fP Specifies the number of columns of the matrix C. N >= 0.
.br
\fIalpha\fP Specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is M when side = PlasmaLeft, and is N otherwise. Only the uplo triangular part is referenced.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,ka).
.br
\fIB\fP B is a LDB-by-N matrix, where the leading M-by-N part of the array B must contain the matrix B.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,M).
.br
\fIbeta\fP Specifies the scalar beta.
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array is overwritten by the M by N updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zsymm_Tile\fP 
.PP
\fBPLASMA_csymm\fP 
.PP
\fBPLASMA_dsymm\fP 
.PP
\fBPLASMA_ssymm\fP 
.RE
.PP

.SS "int PLASMA_zsyr2k (PLASMA_enumuplo, PLASMA_enumtrans, intN, intK, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB, PLASMA_Complex64_tbeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zsyr2k - Performs one of the symmetric rank 2k operations
.PP
\[ C = \alpha [ op( A ) \times conjg( op( B )' )] + \alpha [ op( B ) \times conjg( op( A )' )] + \beta C \], or \[ C = \alpha [ conjg( op( A )' ) \times op( B ) ] + \alpha [ conjg( op( B )' ) \times op( A ) ] + \beta C \],
.PP
where op( X ) is one of
.PP
op( X ) = X or op( X ) = conjg( X' )
.PP
where alpha and beta are real scalars, C is an n-by-n symmetric matrix and A and B are an n-by-k matrices the first case and k-by-n matrices in the second case.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of C is stored; = PlasmaLower: Lower triangle of C is stored.
.br
\fItrans\fP Specifies whether the matrix A is transposed or conjugate transposed: = PlasmaNoTrans: \[ C = \alpha [ op( A ) \times conjg( op( B )' )] + \alpha [ op( B ) \times conjg( op( A )' )] + \beta C \] = PlasmaTrans: \[ C = \alpha [ conjg( op( A )' ) \times op( B ) ] + \alpha [ conjg( op( B )' ) \times op( A ) ] + \beta C \]
.br
\fIN\fP N specifies the order of the matrix C. N must be at least zero.
.br
\fIK\fP K specifies the number of columns of the A and B matrices with trans = PlasmaNoTrans. K specifies the number of rows of the A and B matrices with trans = PlasmaTrans.
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDA\fP The leading dimension of the array A. LDA must be at least max( 1, N ), otherwise LDA must be at least max( 1, K ).
.br
\fIB\fP B is a LDB-by-kb matrix, where kb is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDB\fP The leading dimension of the array B. LDB must be at least max( 1, N ), otherwise LDB must be at least max( 1, K ).
.br
\fIbeta\fP beta specifies the scalar beta.
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max( 1, N ).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zsyr2k_Tile\fP 
.PP
\fBPLASMA_csyr2k\fP 
.PP
\fBPLASMA_dsyr2k\fP 
.PP
\fBPLASMA_ssyr2k\fP 
.RE
.PP

.SS "int PLASMA_zsyrk (PLASMA_enumuplo, PLASMA_enumtrans, intN, intK, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_tbeta, PLASMA_Complex64_t *C, intLDC)"PLASMA_zsyrk - Performs one of the hermitian rank k operations
.PP
\[ C = \alpha [ op( A ) \times conjg( op( A )' )] + \beta C \],
.PP
where op( X ) is one of
.PP
op( X ) = X or op( X ) = conjg( X' )
.PP
where alpha and beta are real scalars, C is an n-by-n hermitian matrix and A is an n-by-k matrix in the first case and a k-by-n matrix in the second case.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of C is stored; = PlasmaLower: Lower triangle of C is stored.
.br
\fItrans\fP Specifies whether the matrix A is transposed or conjugate transposed: = PlasmaNoTrans: A is not transposed; = PlasmaTrans : A is transposed.
.br
\fIN\fP N specifies the order of the matrix C. N must be at least zero.
.br
\fIK\fP K specifies the number of columns of the matrix op( A ).
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP A is a LDA-by-ka matrix, where ka is K when trans = PlasmaNoTrans, and is N otherwise.
.br
\fILDA\fP The leading dimension of the array A. LDA must be at least max( 1, N ), otherwise LDA must be at least max( 1, K ).
.br
\fIbeta\fP beta specifies the scalar beta
.br
\fIC\fP C is a LDC-by-N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.
.br
\fILDC\fP The leading dimension of the array C. LDC >= max( 1, N ).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zsyrk_Tile\fP 
.PP
\fBPLASMA_csyrk\fP 
.PP
\fBPLASMA_dsyrk\fP 
.PP
\fBPLASMA_ssyrk\fP 
.RE
.PP

.SS "int PLASMA_zTile_to_Lapack (\fBPLASMA_desc\fP *A, PLASMA_Complex64_t *Af77, intLDA)"PLASMA_Tile_to_Lapack - Conversion from tile layout to LAPACK layout.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP Descriptor of the PLASMA matrix in tile layout.
.br
\fIAf77\fP LAPACK matrix. If PLASMA_TRANSLATION_MODE is set to PLASMA_INPLACE, Af77 has to be A->mat, else if PLASMA_TRANSLATION_MODE is set to PLASMA_OUTOFPLACE, Af77 has to be allocated before.
.br
\fILDA\fP The leading dimension of the matrix Af77.
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zTile_to_Lapack_Async\fP 
.PP
\fBPLASMA_zLapack_to_Tile\fP 
.PP
\fBPLASMA_cTile_to_Lapack\fP 
.PP
\fBPLASMA_dTile_to_Lapack\fP 
.PP
\fBPLASMA_sTile_to_Lapack\fP 
.RE
.PP

.SS "int PLASMA_ztrmm (PLASMA_enumside, PLASMA_enumuplo, PLASMA_enumtransA, PLASMA_enumdiag, intN, intNRHS, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB)"PLASMA_ztrmm - Computes B = alpha*op( A )*B or B = alpha*B*op( A ).
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Specifies whether A appears on the left or on the right of X: = PlasmaLeft: A*X = B = PlasmaRight: X*A = B
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fItransA\fP Specifies whether the matrix A is transposed, not transposed or conjugate transposed: = PlasmaNoTrans: A is transposed; = PlasmaTrans: A is not transposed; = PlasmaConjTrans: A is conjugate transposed.
.br
\fIdiag\fP Specifies whether or not A is unit triangular: = PlasmaNonUnit: A is non unit; = PlasmaUnit: A us unit.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP The triangular matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = PlasmaUnit, the diagonal elements of A are also not referenced and are assumed to be 1.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the N-by-NRHS right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_ztrmm_Tile\fP 
.PP
\fBPLASMA_ztrmm_Tile_Async\fP 
.PP
\fBPLASMA_ctrmm\fP 
.PP
\fBPLASMA_dtrmm\fP 
.PP
\fBPLASMA_strmm\fP 
.RE
.PP

.SS "int PLASMA_ztrsm (PLASMA_enumside, PLASMA_enumuplo, PLASMA_enumtransA, PLASMA_enumdiag, intN, intNRHS, PLASMA_Complex64_talpha, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *B, intLDB)"PLASMA_ztrsm - Computes triangular solve A*X = B or X*A = B.
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Specifies whether A appears on the left or on the right of X: = PlasmaLeft: A*X = B = PlasmaRight: X*A = B
.br
\fIuplo\fP Specifies whether the matrix A is upper triangular or lower triangular: = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fItransA\fP Specifies whether the matrix A is transposed, not transposed or conjugate transposed: = PlasmaNoTrans: A is transposed; = PlasmaTrans: A is not transposed; = PlasmaConjTrans: A is conjugate transposed.
.br
\fIdiag\fP Specifies whether or not A is unit triangular: = PlasmaNonUnit: A is non unit; = PlasmaUnit: A us unit.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIalpha\fP alpha specifies the scalar alpha.
.br
\fIA\fP The triangular matrix A. If uplo = PlasmaUpper, the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = PlasmaLower, the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = PlasmaUnit, the diagonal elements of A are also not referenced and are assumed to be 1.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIB\fP On entry, the N-by-NRHS right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_ztrsm_Tile\fP 
.PP
\fBPLASMA_ztrsm_Tile_Async\fP 
.PP
\fBPLASMA_ctrsm\fP 
.PP
\fBPLASMA_dtrsm\fP 
.PP
\fBPLASMA_strsm\fP 
.RE
.PP

.SS "int PLASMA_ztrsmpl (intN, intNRHS, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *L, int *IPIV, PLASMA_Complex64_t *B, intLDB)"PLASMA_ztrsmpl - Performs the forward substitution step of solving a system of linear equations after the tile LU factorization of the matrix.
.PP
\fBParameters:\fP
.RS 4
\fIN\fP The order of the matrix A. N >= 0.
.br
\fINRHS\fP The number of right hand sides, i.e., the number of columns of the matrix B. NRHS >= 0.
.br
\fIA\fP The tile factor L from the factorization, computed by PLASMA_zgetrf_incpiv.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.br
\fIL\fP Auxiliary factorization data, related to the tile L factor, computed by PLASMA_zgetrf_incpiv.
.br
\fIIPIV\fP The pivot indices from PLASMA_zgetrf_incpiv (not equivalent to LAPACK).
.br
\fIB\fP On entry, the N-by-NRHS right hand side matrix B. On exit, if return value = 0, the N-by-NRHS solution matrix X.
.br
\fILDB\fP The leading dimension of the array B. LDB >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_ztrsmpl_Tile\fP 
.PP
\fBPLASMA_ztrsmpl_Tile_Async\fP 
.PP
\fBPLASMA_ctrsmpl\fP 
.PP
\fBPLASMA_dtrsmpl\fP 
.PP
\fBPLASMA_strsmpl\fP 
.PP
\fBPLASMA_zgetrf_incpiv\fP 
.RE
.PP

.SS "int PLASMA_ztrtri (PLASMA_enumuplo, PLASMA_enumdiag, intN, PLASMA_Complex64_t *A, intLDA)"PLASMA_ztrtri - Computes the inverse of a complex upper or lower triangular matrix A.
.PP
\fBParameters:\fP
.RS 4
\fIuplo\fP = PlasmaUpper: Upper triangle of A is stored; = PlasmaLower: Lower triangle of A is stored.
.br
\fIdiag\fP = PlasmaNonUnit: A is non-unit triangular; = PlasmaUnit: A is unit triangular.
.br
\fIN\fP The order of the matrix A. N >= 0.
.br
\fIA\fP On entry, the triangular matrix A. If UPLO = 'U', the leading N-by-N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If UPLO = 'L', the leading N-by-N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If DIAG = 'U', the diagonal elements of A are also not referenced and are assumed to be 1. On exit, the (triangular) inverse of the original matrix, in the same storage format.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,N).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value 
.br
\fI>0\fP if i, A(i,i) is exactly zero. The triangular matrix is singular and its inverse can not be computed.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_ztrtri_Tile\fP 
.PP
\fBPLASMA_ztrtri_Tile_Async\fP 
.PP
\fBPLASMA_ctrtri\fP 
.PP
\fBPLASMA_dtrtri\fP 
.PP
\fBPLASMA_strtri\fP 
.PP
\fBPLASMA_zpotri\fP 
.RE
.PP

.SS "int PLASMA_zunglq (intM, intN, intK, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zunglq - Generates an M-by-N matrix Q with orthonormal rows, which is defined as the first M rows of a product of the elementary reflectors returned by PLASMA_zgelqf.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix Q. M >= 0.
.br
\fIN\fP The number of columns of the matrix Q. N >= M.
.br
\fIK\fP The number of rows of elementary tile reflectors whose product defines the matrix Q. M >= K >= 0.
.br
\fIA\fP Details of the LQ factorization of the original matrix A as returned by PLASMA_zgelqf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgelqf.
.br
\fIQ\fP On exit, the M-by-N matrix Q.
.br
\fILDQ\fP The leading dimension of the array Q. LDQ >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fIPLASMA_SUCCESS\fP <0 if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zunglq_Tile\fP 
.PP
\fBPLASMA_zunglq_Tile_Async\fP 
.PP
\fBPLASMA_cunglq\fP 
.PP
\fBPLASMA_dorglq\fP 
.PP
\fBPLASMA_sorglq\fP 
.PP
\fBPLASMA_zgelqf\fP 
.RE
.PP

.SS "int PLASMA_zungqr (intM, intN, intK, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *Q, intLDQ)"PLASMA_zungqr - Generates an M-by-N matrix Q with orthonormal columns, which is defined as the first N columns of a product of the elementary reflectors returned by PLASMA_zgeqrf.
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The number of rows of the matrix Q. M >= 0.
.br
\fIN\fP The number of columns of the matrix Q. N >= M.
.br
\fIK\fP The number of columns of elementary tile reflectors whose product defines the matrix Q. M >= K >= 0.
.br
\fIA\fP Details of the QR factorization of the original matrix A as returned by PLASMA_zgeqrf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,M).
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgeqrf.
.br
\fIQ\fP On exit, the M-by-N matrix Q.
.br
\fILDQ\fP The leading dimension of the array Q. LDQ >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zungqr_Tile\fP 
.PP
\fBPLASMA_zungqr_Tile_Async\fP 
.PP
\fBPLASMA_cungqr\fP 
.PP
\fBPLASMA_dorgqr\fP 
.PP
\fBPLASMA_sorgqr\fP 
.PP
\fBPLASMA_zgeqrf\fP 
.RE
.PP

.SS "int PLASMA_zunmlq (PLASMA_enumside, PLASMA_enumtrans, intM, intN, intK, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, intLDB)"PLASMA_zunmlq - overwrites the general M-by-N matrix C with Q*C, where Q is an orthogonal matrix (unitary in the complex case) defined as the product of elementary reflectors returned by PLASMA_zgelqf. Q is of order M.
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Intended usage: = PlasmaLeft: apply Q or Q**H from the left; = PlasmaRight: apply Q or Q**H from the right. Currently only PlasmaLeft is supported.
.br
\fItrans\fP Intended usage: = PlasmaNoTrans: no transpose, apply Q; = PlasmaConjTrans: conjugate transpose, apply Q**H. Currently only PlasmaConjTrans is supported.
.br
\fIM\fP The number of rows of the matrix C. M >= 0.
.br
\fIN\fP The number of columns of the matrix C. N >= 0.
.br
\fIK\fP The number of rows of elementary tile reflectors whose product defines the matrix Q. M >= K >= 0.
.br
\fIA\fP Details of the LQ factorization of the original matrix A as returned by PLASMA_zgelqf.
.br
\fILDA\fP The leading dimension of the array A. LDA >= max(1,K).
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgelqf.
.br
\fIB\fP On entry, the M-by-N matrix B. On exit, B is overwritten by Q*B or Q**H*B.
.br
\fILDB\fP The leading dimension of the array C. LDC >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zunmlq_Tile\fP 
.PP
\fBPLASMA_zunmlq_Tile_Async\fP 
.PP
\fBPLASMA_cunmlq\fP 
.PP
\fBPLASMA_dormlq\fP 
.PP
\fBPLASMA_sormlq\fP 
.PP
\fBPLASMA_zgelqf\fP 
.RE
.PP

.SS "int PLASMA_zunmqr (PLASMA_enumside, PLASMA_enumtrans, intM, intN, intK, PLASMA_Complex64_t *A, intLDA, PLASMA_Complex64_t *T, PLASMA_Complex64_t *B, intLDB)"PLASMA_zunmqr - overwrites the general M-by-N matrix C with Q*C, where Q is an orthogonal matrix (unitary in the complex case) defined as the product of elementary reflectors returned by PLASMA_zgeqrf. Q is of order M.
.PP
\fBParameters:\fP
.RS 4
\fIside\fP Intended usage: = PlasmaLeft: apply Q or Q**H from the left; = PlasmaRight: apply Q or Q**H from the right. Currently only PlasmaLeft is supported.
.br
\fItrans\fP Intended usage: = PlasmaNoTrans: no transpose, apply Q; = PlasmaConjTrans: conjugate transpose, apply Q**H. Currently only PlasmaConjTrans is supported.
.br
\fIM\fP The number of rows of the matrix C. M >= 0.
.br
\fIN\fP The number of columns of the matrix C. N >= 0.
.br
\fIK\fP The number of columns of elementary tile reflectors whose product defines the matrix Q. If side == PlasmaLeft, M >= K >= 0. If side == PlasmaRight, N >= K >= 0.
.br
\fIA\fP Details of the QR factorization of the original matrix A as returned by PLASMA_zgeqrf.
.br
\fILDA\fP The leading dimension of the array A. If side == PlasmaLeft, LDA >= max(1,M). If side == PlasmaRight, LDA >= max(1,N).
.br
\fIT\fP Auxiliary factorization data, computed by PLASMA_zgeqrf.
.br
\fIB\fP On entry, the M-by-N matrix B. On exit, B is overwritten by Q*B or Q**H*B.
.br
\fILDB\fP The leading dimension of the array C. LDC >= max(1,M).
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPLASMA_SUCCESS\fP successful exit 
.br
\fI<0\fP if -i, the i-th argument had an illegal value
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPLASMA_zunmqr_Tile\fP 
.PP
\fBPLASMA_zunmqr_Tile_Async\fP 
.PP
\fBPLASMA_cunmqr\fP 
.PP
\fBPLASMA_dormqr\fP 
.PP
\fBPLASMA_sormqr\fP 
.PP
\fBPLASMA_zgeqrf\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for PLASMA from the source code.
